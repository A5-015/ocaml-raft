/* This file has been auto-generated by the SPL compiler */

/* State definitions */
#define S_initial_22  0
#define S_final_23  1
#define S_final_5  2
#define S_initial_4  3
#define S_final_2  4
#define S_initial_1  5
#define S_initial_15  6
#define S_final_16  7

/* Message definitions */
mtype = { Null_msg,
  RestartElecton, 
  Startup, 
  StepDown_from_candidate, 
  StartElecton, 
  WinElection, 
  Raft, 
  Recover, 
}
bool err = false;
bool gen_done = false;
local mtype r;
mtype p;


/* Automaton for: leader */
chan chan_leader = [0] of {mtype}
unsigned leader_state : 4 = S_initial_22;
bool leader_done = false;
active proctype p_leader () {
  atomic {
  if
  :: leader_state = S_initial_22
  fi;
  do
  :: chan_leader?r -> if
    :: leader_state == S_final_23 ->
      assert(0);
    :: leader_state == S_initial_22 ->
      if
      :: r == WinElection -> if
        :: true -> goto leader_end_full
      fi;
        :: else -> goto leader_bad_statecall
      fi
  fi
  :: gen_done -> goto leader_end_full
  od;
  assert(0);

  /* All other states are bad */
  leader_bad_statecall:
  printf("MSC: Bad_statecall exception\n");
  err = true;
  leader_end_full:
  printf("MSC: End state reached\n");
  leader_done = true
  } /* atomic end */
}

/* Automaton for: follower */
chan chan_follower = [0] of {mtype}
unsigned follower_state : 4 = S_initial_4;
bool follower_done = false;
active proctype p_follower () {
  atomic {
  if
  :: follower_state = S_initial_4
  fi;
  do
  :: chan_follower?r -> if
    :: follower_state == S_initial_4 ->
      if
      :: r == Startup -> if
        :: true -> goto follower_end_full
      fi;
      :: r == StepDown_from_candidate -> if
        :: true -> goto follower_end_full
        :: true -> goto follower_end_full
      fi;
      :: r == Recover -> if
        :: true -> goto follower_end_full
      fi;
        :: else -> goto follower_bad_statecall
      fi
    :: follower_state == S_final_5 ->
      assert(0);
  fi
  :: gen_done -> goto follower_end_full
  od;
  assert(0);

  /* All other states are bad */
  follower_bad_statecall:
  printf("MSC: Bad_statecall exception\n");
  err = true;
  follower_end_full:
  printf("MSC: End state reached\n");
  follower_done = true
  } /* atomic end */
}

/* Automaton for: raft_general */
chan chan_raft_general = [0] of {mtype}
unsigned raft_general_state : 4 = S_initial_1;
bool raft_general_done = false;
active proctype p_raft_general () {
  atomic {
  if
  :: raft_general_state = S_initial_1
  fi;
  do
  :: chan_raft_general?r -> if
    :: raft_general_state == S_initial_1 ->
      if
      :: r == Raft -> if
        :: true -> goto raft_general_end_full
      fi;
        :: else -> goto raft_general_bad_statecall
      fi
    :: raft_general_state == S_final_2 ->
      assert(0);
  fi
  :: gen_done -> goto raft_general_end_full
  od;
  assert(0);

  /* All other states are bad */
  raft_general_bad_statecall:
  printf("MSC: Bad_statecall exception\n");
  err = true;
  raft_general_end_full:
  printf("MSC: End state reached\n");
  raft_general_done = true
  } /* atomic end */
}

/* Automaton for: candidate */
chan chan_candidate = [0] of {mtype}
unsigned candidate_state : 4 = S_initial_15;
bool candidate_done = false;
active proctype p_candidate () {
  atomic {
  if
  :: candidate_state = S_initial_15
  fi;
  do
  :: chan_candidate?r -> if
    :: candidate_state == S_final_16 ->
      assert(0);
    :: candidate_state == S_initial_15 ->
      if
      :: r == RestartElecton -> if
        :: true -> goto candidate_end_full
      fi;
      :: r == StartElecton -> if
        :: true -> goto candidate_end_full
      fi;
        :: else -> goto candidate_bad_statecall
      fi
  fi
  :: gen_done -> goto candidate_end_full
  od;
  assert(0);

  /* All other states are bad */
  candidate_bad_statecall:
  printf("MSC: Bad_statecall exception\n");
  err = true;
  candidate_end_full:
  printf("MSC: End state reached\n");
  candidate_done = true
  } /* atomic end */
}

/* Statecall Generator */
active proctype generator() {
  progress:
  do
  :: atomic { !err; 
    if :: chan_candidate!RestartElecton; p=RestartElecton ::candidate_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_follower!Startup; p=Startup ::follower_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_follower!StepDown_from_candidate; p=StepDown_from_candidate ::follower_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_candidate!StartElecton; p=StartElecton ::candidate_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_leader!WinElection; p=WinElection ::leader_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_raft_general!Raft; p=Raft ::raft_general_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_follower!Recover; p=Recover ::follower_done || err -> goto end_gen fi;
    }
  :: err -> goto end_gen
  od;
  end_gen: gen_done = true
}

