/* This file has been auto-generated by the SPL compiler */

/* State definitions */
#define S_seq_3  0
#define S_do_13  1
#define S_h_exit_7  2
#define S_seq_14  3
#define S_assign_12  4
#define S_h_init_6  5
#define S_final_2  6
#define S_until_18  7
#define S_seq_9  8
#define S_initial_1  9

/* Message definitions */
mtype = { Null_msg,
  Initialize, 
  Election_Timeout, 
  Recieve_Vote, 
  Leader_Discovery, 
  Become_Leader, 
}
bool err = false;
bool gen_done = false;
local mtype r;
mtype p;


/* Automaton for: raft_startup */
chan chan_raft_startup = [0] of {mtype}
unsigned raft_startup_state : 4 = S_initial_1;
bool raft_startup_done = false;
byte raft_startup_nodes = 0;
byte raft_startup_count = 0;
byte h_ret_5 = 0;
active proctype p_raft_startup () {
  atomic {
  if
  :: raft_startup_state = S_initial_1
  fi;
  do
  :: chan_raft_startup?r -> if
    :: raft_startup_state == S_initial_1 ->
      if
      :: r == Initialize -> if
        :: raft_startup_state = S_seq_3
        :: h_ret_5 = 10 -> if
          :: raft_startup_state = S_h_init_6
        fi;
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
    :: raft_startup_state == S_seq_9 ->
      assert(0);
    :: raft_startup_state == S_until_18 ->
      if
      :: r == Become_Leader -> if
        :: true -> goto raft_startup_end_full
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
    :: raft_startup_state == S_final_2 ->
      assert(0);
    :: raft_startup_state == S_h_init_6 ->
      if
      :: r == Leader_Discovery -> if
        :: (h_ret_5 == 10) -> if
          :: raft_startup_state = S_seq_3
          :: h_ret_5 = 10 -> if
            :: raft_startup_state = S_h_init_6
          fi;
        fi;
        :: (h_ret_5 == 20) -> if
          :: raft_startup_state = S_until_18
          :: h_ret_5 = 20 -> if
            :: raft_startup_state = S_h_init_6
          fi;
        fi;
        :: (h_ret_5 == 15) -> if
          :: raft_startup_state = S_assign_12
          :: h_ret_5 = 15 -> if
            :: raft_startup_state = S_h_init_6
          fi;
        fi;
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
    :: raft_startup_state == S_assign_12 ->
      if
      :: r == Recieve_Vote -> if
        :: raft_startup_count = (raft_startup_count + 1) -> if
          :: (!((raft_startup_count * 2) >= raft_startup_nodes)) -> if
            :: raft_startup_state = S_assign_12
            :: h_ret_5 = 15 -> if
              :: raft_startup_state = S_h_init_6
            fi;
          fi;
          :: ((raft_startup_count * 2) >= raft_startup_nodes) -> if
            :: raft_startup_state = S_until_18
            :: h_ret_5 = 20 -> if
              :: raft_startup_state = S_h_init_6
            fi;
          fi;
        fi;
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
    :: raft_startup_state == S_seq_14 ->
      assert(0);
    :: raft_startup_state == S_h_exit_7 ->
      assert(0);
    :: raft_startup_state == S_do_13 ->
      assert(0);
    :: raft_startup_state == S_seq_3 ->
      if
      :: r == Election_Timeout -> if
        :: raft_startup_count = 0 -> if
          :: raft_startup_state = S_assign_12
          :: h_ret_5 = 15 -> if
            :: raft_startup_state = S_h_init_6
          fi;
        fi;
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
  fi
  :: gen_done -> goto raft_startup_end_full
  od;
  assert(0);

  /* All other states are bad */
  raft_startup_bad_statecall:
  printf("MSC: Bad_statecall exception\n");
  err = true;
  raft_startup_end_full:
  printf("MSC: End state reached\n");
  raft_startup_done = true
  } /* atomic end */
}

/* Statecall Generator */
active proctype generator() {
  progress:
  do
  :: atomic { !err; 
    if :: chan_raft_startup!Initialize; p=Initialize ::raft_startup_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_raft_startup!Election_Timeout; p=Election_Timeout ::raft_startup_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_raft_startup!Recieve_Vote; p=Recieve_Vote ::raft_startup_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_raft_startup!Leader_Discovery; p=Leader_Discovery ::raft_startup_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_raft_startup!Become_Leader; p=Become_Leader ::raft_startup_done || err -> goto end_gen fi;
    }
  :: err -> goto end_gen
  od;
  end_gen: gen_done = true
}

