/* This file has been auto-generated by the SPL compiler */

/* State definitions */
#define S_func_pop_44  0
#define S_initial_36  1
#define S_seq_38  2
#define S_func_exit_43  3
#define S_func_push_ret_40  4
#define S_final_37  5
#define S_func_push_41  6
#define S_until_30  7
#define S_seq_18  8
#define S_final_2  9
#define S_do_23  10
#define S_assign_17  11
#define S_seq_12  12
#define S_h_init_9  13
#define S_h_exit_6  14
#define S_h_init_5  15
#define S_h_exit_10  16
#define S_initial_1  17
#define S_seq_24  18

/* Message definitions */
mtype = { Null_msg,
  Initialize, 
  Election_Timeout, 
  Recieve_Vote, 
  Broadcast_RequestVoteRPC, 
  Leader_Discovery, 
  Failure, 
  Become_Leader, 
}
bool err = false;
bool gen_done = false;
local mtype r;
mtype p;


/* Automaton for: raft_startup */
chan chan_raft_startup = [0] of {mtype}
unsigned raft_startup_state : 5 = S_initial_36;
bool raft_startup_done = false;
byte h_ret_8 = 0;
byte raft_startup_nodes = 0;
byte raft_startup_count = 0;
byte h_ret_4 = 0;
byte candidate_return = 0;
byte candidate_count = 0;
byte candidate_nodes = 0;
active proctype p_raft_startup () {
  atomic {
  if
  :: raft_startup_state = S_initial_36
  fi;
  do
  :: chan_raft_startup?r -> if
    :: raft_startup_state == S_seq_24 ->
      assert(0);
    :: raft_startup_state == S_initial_1 ->
      if
      :: r == Election_Timeout -> if
        :: candidate_count = 0 -> if
          :: raft_startup_state = S_assign_17
          :: h_ret_8 = 21 -> if
            :: raft_startup_state = S_h_init_9
          fi;
          :: h_ret_4 = 19 -> if
            :: raft_startup_state = S_h_init_5
          fi;
        fi;
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
    :: raft_startup_state == S_h_exit_10 ->
      assert(0);
    :: raft_startup_state == S_h_init_5 ->
      if
      :: r == Leader_Discovery -> if
        :: (candidate_return == 39) -> if
          :: raft_startup_nodes = candidate_nodes -> if
            :: raft_startup_count = candidate_count -> if
              :: true -> goto raft_startup_end_full
            fi;
          fi;
        fi;
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
    :: raft_startup_state == S_h_exit_6 ->
      assert(0);
    :: raft_startup_state == S_h_init_9 ->
      if
      :: r == Failure -> if
        :: (candidate_return == 39) -> if
          :: raft_startup_nodes = candidate_nodes -> if
            :: raft_startup_count = candidate_count -> if
              :: true -> goto raft_startup_end_full
            fi;
          fi;
        fi;
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
    :: raft_startup_state == S_seq_12 ->
      assert(0);
    :: raft_startup_state == S_assign_17 ->
      if
      :: r == Broadcast_RequestVoteRPC -> if
        :: raft_startup_state = S_seq_18
        :: h_ret_4 = 25 -> if
          :: raft_startup_state = S_h_init_5
        fi;
        :: h_ret_8 = 27 -> if
          :: raft_startup_state = S_h_init_9
        fi;
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
    :: raft_startup_state == S_do_23 ->
      assert(0);
    :: raft_startup_state == S_final_2 ->
      assert(0);
    :: raft_startup_state == S_seq_18 ->
      if
      :: r == Recieve_Vote -> if
        :: candidate_count = (candidate_count + 1) -> if
          :: ((candidate_count * 2) >= candidate_nodes) -> if
            :: raft_startup_state = S_until_30
            :: h_ret_8 = 34 -> if
              :: raft_startup_state = S_h_init_9
            fi;
            :: h_ret_4 = 32 -> if
              :: raft_startup_state = S_h_init_5
            fi;
          fi;
          :: (!((candidate_count * 2) >= candidate_nodes)) -> if
            :: raft_startup_state = S_seq_18
            :: h_ret_4 = 25 -> if
              :: raft_startup_state = S_h_init_5
            fi;
            :: h_ret_8 = 27 -> if
              :: raft_startup_state = S_h_init_9
            fi;
          fi;
        fi;
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
    :: raft_startup_state == S_until_30 ->
      if
      :: r == Become_Leader -> if
        :: (candidate_return == 39) -> if
          :: raft_startup_nodes = candidate_nodes -> if
            :: raft_startup_count = candidate_count -> if
              :: true -> goto raft_startup_end_full
            fi;
          fi;
        fi;
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
    :: raft_startup_state == S_func_push_41 ->
      assert(0);
    :: raft_startup_state == S_final_37 ->
      assert(0);
    :: raft_startup_state == S_func_push_ret_40 ->
      assert(0);
    :: raft_startup_state == S_func_exit_43 ->
      assert(0);
    :: raft_startup_state == S_seq_38 ->
      assert(0);
    :: raft_startup_state == S_initial_36 ->
      if
      :: r == Initialize -> if
        :: candidate_return = 39 -> if
          :: candidate_nodes = raft_startup_nodes -> if
            :: candidate_count = raft_startup_count -> if
              :: raft_startup_state = S_initial_1
              :: h_ret_8 = 15 -> if
                :: raft_startup_state = S_h_init_9
              fi;
              :: h_ret_4 = 13 -> if
                :: raft_startup_state = S_h_init_5
              fi;
            fi;
          fi;
        fi;
      fi;
        :: else -> goto raft_startup_bad_statecall
      fi
    :: raft_startup_state == S_func_pop_44 ->
      assert(0);
  fi
  :: gen_done -> goto raft_startup_end_full
  od;
  assert(0);

  /* All other states are bad */
  raft_startup_bad_statecall:
  printf("MSC: Bad_statecall exception\n");
  err = true;
  raft_startup_end_full:
  printf("MSC: End state reached\n");
  raft_startup_done = true
  } /* atomic end */
}

/* Statecall Generator */
active proctype generator() {
  progress:
  do
  :: atomic { !err; 
    if :: chan_raft_startup!Initialize; p=Initialize ::raft_startup_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    }
  :: atomic { !err; 
    }
  :: atomic { !err; 
    }
  :: atomic { !err; 
    }
  :: atomic { !err; 
    }
  :: atomic { !err; 
    }
  :: err -> goto end_gen
  od;
  end_gen: gen_done = true
}

