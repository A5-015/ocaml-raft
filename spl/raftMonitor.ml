(* This file has been auto-generated by the SPL compiler *)
exception Bad_statecall

module Raft_general = struct
  type state = {
    multiple_13: int;
    multiple_20: int;
  }

  type states = (int, state list) Hashtbl.t

  let register_state (s:int) (x:state) h =
    try let l = Hashtbl.find h s in
    if not (List.mem x l) then Hashtbl.replace h s (x :: l)
    with Not_found -> Hashtbl.add h s [x]

  let rec tick msg (s:states) : states =
    let h = Hashtbl.create 17 in
    Hashtbl.iter (fun st xs -> List.iter (fun x -> match st,msg with
    |10,`Startup (* S_initial_1 *) ->
      (* S_either_or_3 *)
      begin (* let multiple_13 = 0 in *) 
        (* S_multentry_9 *)
        register_state 2 {x with multiple_13=0} h; (* S_multentry_9 *)
      end;
      begin (* let multiple_13 = 0 in *) 
        (* S_final_2 *)
        register_state 1 {x with multiple_13=0} h; (* S_final_2 *)
      end;
    |10,`Recover (* S_initial_1 *) ->
      (* S_either_or_3 *)
      begin (* let multiple_13 = 0 in *) 
        (* S_multentry_9 *)
        register_state 2 {x with multiple_13=0} h; (* S_multentry_9 *)
      end;
      begin (* let multiple_13 = 0 in *) 
        (* S_final_2 *)
        register_state 1 {x with multiple_13=0} h; (* S_final_2 *)
      end;
    |9,`RestartElection (* S_multentry_16 *) ->
      (* S_multblexit_18 *)
      begin (* let multiple_20 = (x.multiple_20 + 1) in *) 
        (* S_multentry_16 *)
        register_state 9 {x with multiple_20=(x.multiple_20 + 1)} h; (* S_multentry_16 *)
      end;
      begin (* let multiple_20 = (x.multiple_20 + 1) in *) 
        (* S_or_25 *)
        register_state 8 {x with multiple_20=(x.multiple_20 + 1)} h; (* S_or_25 *)
      end;
      begin (* let multiple_20 = (x.multiple_20 + 1) in *) 
        (* S_or_23 *)
        register_state 4 {x with multiple_20=(x.multiple_20 + 1)} h; (* S_or_23 *)
      end;
    |8,`WinElection (* S_or_25 *) ->
      (* S_seq_26 *)
      register_state 3 x h; (* S_seq_26 *)
    |4,`StepDown_from_Candidate (* S_or_23 *) ->
      (* S_multblexit_11 *)
      begin (* let multiple_13 = (x.multiple_13 + 1) in *) 
        (* S_multentry_9 *)
        register_state 2 {x with multiple_13=(x.multiple_13 + 1)} h; (* S_multentry_9 *)
      end;
      begin (* let multiple_13 = (x.multiple_13 + 1) in *) 
        (* S_final_2 *)
        register_state 1 {x with multiple_13=(x.multiple_13 + 1)} h; (* S_final_2 *)
      end;
    |3,`StepDown_from_Leader (* S_seq_26 *) ->
      (* S_multblexit_11 *)
      begin (* let multiple_13 = (x.multiple_13 + 1) in *) 
        (* S_multentry_9 *)
        register_state 2 {x with multiple_13=(x.multiple_13 + 1)} h; (* S_multentry_9 *)
      end;
      begin (* let multiple_13 = (x.multiple_13 + 1) in *) 
        (* S_final_2 *)
        register_state 1 {x with multiple_13=(x.multiple_13 + 1)} h; (* S_final_2 *)
      end;
    |2,`StartElection (* S_multentry_9 *) ->
      (* S_seq_14 *)
      begin (* let multiple_20 = 0 in *) 
        (* S_multentry_16 *)
        register_state 9 {x with multiple_20=0} h; (* S_multentry_16 *)
      end;
      begin (* let multiple_20 = 0 in *) 
        (* S_or_25 *)
        register_state 8 {x with multiple_20=0} h; (* S_or_25 *)
      end;
      begin (* let multiple_20 = 0 in *) 
        (* S_or_23 *)
        register_state 4 {x with multiple_20=0} h; (* S_or_23 *)
      end;
     |_ -> ()
    ) xs) s;
    if Hashtbl.length h = 0 then raise Bad_statecall else h

  let init () =
    let h = Hashtbl.create 17 in
    let x = {
    multiple_13 = 0;
    multiple_20 = 0;
    } in
    (* S_initial_1 *)
    register_state 10 x h; (* S_initial_1 *)
    h

  let active = function
  |10 (* S_initial_1 *) -> [3;1]
  |9 (* S_multentry_16 *) -> [8]
  |8 (* S_or_25 *) -> [13]
  |7 (* S_either_or_3 *) -> []
  |6 (* S_multblexit_11 *) -> []
  |5 (* S_multblexit_18 *) -> []
  |4 (* S_or_23 *) -> [11]
  |3 (* S_seq_26 *) -> [14]
  |2 (* S_multentry_9 *) -> [6]
  |1 (* S_final_2 *) -> []
  |0 (* S_seq_14 *) -> []
  |_ -> failwith "internal error"
end

type s = [
  |`RestartElection
  |`StartElection
  |`Startup
  |`StepDown_from_Candidate
  |`StepDown_from_Leader
  |`WinElection
  |`Recover
]

type t = {
  raft_general: Raft_general.states;
}

let pagefn (oc:out_channel) = ()
let set_cfn _ _ = ()
let init () = {
  raft_general = Raft_general.init ();
}


let tick s x =
  let r = match x with
  |`RestartElection -> 
    {s with
    raft_general = (Raft_general.tick `RestartElection s.raft_general);
    }
  |`StartElection -> 
    {s with
    raft_general = (Raft_general.tick `StartElection s.raft_general);
    }
  |`Startup -> 
    {s with
    raft_general = (Raft_general.tick `Startup s.raft_general);
    }
  |`StepDown_from_Candidate -> 
    {s with
    raft_general = (Raft_general.tick `StepDown_from_Candidate s.raft_general);
    }
  |`StepDown_from_Leader -> 
    {s with
    raft_general = (Raft_general.tick `StepDown_from_Leader s.raft_general);
    }
  |`WinElection -> 
    {s with
    raft_general = (Raft_general.tick `WinElection s.raft_general);
    }
  |`Recover -> 
    {s with
    raft_general = (Raft_general.tick `Recover s.raft_general);
    }
  |_ -> s in r
