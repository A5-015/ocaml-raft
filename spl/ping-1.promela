/* This file has been auto-generated by the SPL compiler */

/* State definitions */
#define S_seq_3  0
#define S_final_2  1
#define S_multinit_4  2
#define S_seq_10  3
#define S_multblexit_7  4
#define S_initial_1  5

/* Message definitions */
mtype = { Null_msg,
  Initialize, 
  Transmit_Ping, 
  Receive_Ping, 
}
bool err = false;
bool gen_done = false;
local mtype r;
mtype p;


/* Automaton for: ping */
chan chan_ping = [0] of {mtype}
unsigned ping_state : 3 = S_initial_1;
bool ping_done = false;
byte multiple_9 = 0;
active proctype p_ping () {
  atomic {
  if
  :: ping_state = S_initial_1
  fi;
  do
  :: chan_ping?r -> if
    :: ping_state == S_initial_1 ->
      if
      :: r == Initialize -> if
        :: multiple_9 = 0 -> if
          :: ping_state = S_multinit_4
          :: (multiple_9 >= 1) -> if
            :: true -> goto ping_end_full
          fi;
        fi;
      fi;
        :: else -> goto ping_bad_statecall
      fi
    :: ping_state == S_multblexit_7 ->
      assert(0);
    :: ping_state == S_seq_10 ->
      if
      :: r == Receive_Ping -> if
        :: multiple_9 = (multiple_9 + 1) -> if
          :: ping_state = S_multinit_4
          :: (multiple_9 >= 1) -> if
            :: true -> goto ping_end_full
          fi;
        fi;
      fi;
        :: else -> goto ping_bad_statecall
      fi
    :: ping_state == S_multinit_4 ->
      if
      :: r == Transmit_Ping -> if
        :: ping_state = S_seq_10
      fi;
        :: else -> goto ping_bad_statecall
      fi
    :: ping_state == S_final_2 ->
      assert(0);
    :: ping_state == S_seq_3 ->
      assert(0);
  fi
  :: gen_done -> goto ping_end_full
  od;
  assert(0);

  /* All other states are bad */
  ping_bad_statecall:
  printf("MSC: Bad_statecall exception\n");
  err = true;
  ping_end_full:
  printf("MSC: End state reached\n");
  ping_done = true
  } /* atomic end */
}

/* Statecall Generator */
active proctype generator() {
  progress:
  do
  :: atomic { !err; 
    if :: chan_ping!Initialize; p=Initialize ::ping_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_ping!Transmit_Ping; p=Transmit_Ping ::ping_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_ping!Receive_Ping; p=Receive_Ping ::ping_done || err -> goto end_gen fi;
    }
  :: err -> goto end_gen
  od;
  end_gen: gen_done = true
}

