/* This file has been auto-generated by the SPL compiler */

/* State definitions */
#define S_seq_14  0
#define S_final_2  1
#define S_multentry_9  2
#define S_seq_26  3
#define S_or_23  4
#define S_multblexit_18  5
#define S_multblexit_11  6
#define S_either_or_3  7
#define S_or_25  8
#define S_multentry_16  9
#define S_initial_1  10

/* Message definitions */
mtype = { Null_msg,
  RestartElecton, 
  Startup, 
  StepDown_from_Candidate, 
  StepDown_from_Leader, 
  StartElecton, 
  WinElecton, 
  Recover, 
}
bool err = false;
bool gen_done = false;
local mtype r;
mtype p;


/* Automaton for: raft_general */
chan chan_raft_general = [0] of {mtype}
unsigned raft_general_state : 4 = S_initial_1;
bool raft_general_done = false;
byte multiple_20 = 0;
byte multiple_13 = 0;
active proctype p_raft_general () {
  atomic {
  if
  :: raft_general_state = S_initial_1
  fi;
  do
  :: chan_raft_general?r -> if
    :: raft_general_state == S_initial_1 ->
      if
      :: r == Startup -> if
        :: multiple_13 = 0 -> if
          :: true -> goto raft_general_end_full
          :: raft_general_state = S_multentry_9
        fi;
      fi;
      :: r == Recover -> if
        :: multiple_13 = 0 -> if
          :: true -> goto raft_general_end_full
          :: raft_general_state = S_multentry_9
        fi;
      fi;
        :: else -> goto raft_general_bad_statecall
      fi
    :: raft_general_state == S_multentry_16 ->
      if
      :: r == RestartElecton -> if
        :: multiple_20 = (multiple_20 + 1) -> if
          :: raft_general_state = S_or_23
          :: raft_general_state = S_or_25
          :: raft_general_state = S_multentry_16
        fi;
      fi;
        :: else -> goto raft_general_bad_statecall
      fi
    :: raft_general_state == S_or_25 ->
      if
      :: r == WinElecton -> if
        :: raft_general_state = S_seq_26
      fi;
        :: else -> goto raft_general_bad_statecall
      fi
    :: raft_general_state == S_either_or_3 ->
      assert(0);
    :: raft_general_state == S_multblexit_11 ->
      assert(0);
    :: raft_general_state == S_multblexit_18 ->
      assert(0);
    :: raft_general_state == S_or_23 ->
      if
      :: r == StepDown_from_Candidate -> if
        :: multiple_13 = (multiple_13 + 1) -> if
          :: true -> goto raft_general_end_full
          :: raft_general_state = S_multentry_9
        fi;
      fi;
        :: else -> goto raft_general_bad_statecall
      fi
    :: raft_general_state == S_seq_26 ->
      if
      :: r == StepDown_from_Leader -> if
        :: multiple_13 = (multiple_13 + 1) -> if
          :: true -> goto raft_general_end_full
          :: raft_general_state = S_multentry_9
        fi;
      fi;
        :: else -> goto raft_general_bad_statecall
      fi
    :: raft_general_state == S_multentry_9 ->
      if
      :: r == StartElecton -> if
        :: multiple_20 = 0 -> if
          :: raft_general_state = S_or_23
          :: raft_general_state = S_or_25
          :: raft_general_state = S_multentry_16
        fi;
      fi;
        :: else -> goto raft_general_bad_statecall
      fi
    :: raft_general_state == S_final_2 ->
      assert(0);
    :: raft_general_state == S_seq_14 ->
      assert(0);
  fi
  :: gen_done -> goto raft_general_end_full
  od;
  assert(0);

  /* All other states are bad */
  raft_general_bad_statecall:
  printf("MSC: Bad_statecall exception\n");
  err = true;
  raft_general_end_full:
  printf("MSC: End state reached\n");
  raft_general_done = true
  } /* atomic end */
}

/* Statecall Generator */
active proctype generator() {
  progress:
  do
  :: atomic { !err; 
    if :: chan_raft_general!RestartElecton; p=RestartElecton ::raft_general_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_raft_general!Startup; p=Startup ::raft_general_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_raft_general!StepDown_from_Candidate; p=StepDown_from_Candidate ::raft_general_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_raft_general!StepDown_from_Leader; p=StepDown_from_Leader ::raft_general_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_raft_general!StartElecton; p=StartElecton ::raft_general_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_raft_general!WinElecton; p=WinElecton ::raft_general_done || err -> goto end_gen fi;
    }
  :: atomic { !err; 
    if :: chan_raft_general!Recover; p=Recover ::raft_general_done || err -> goto end_gen fi;
    }
  :: err -> goto end_gen
  od;
  end_gen: gen_done = true
}

